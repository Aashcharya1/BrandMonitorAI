{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user account within the BrandGuardian application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "Email address of the user.",
          "format": "email"
        },
        "passwordHash": {
          "type": "string",
          "description": "Hashed password of the user. Store securely using bcrypt or argon2."
        },
        "provider": {
          "type": "string",
          "description": "Authentication provider used by the user (e.g., local, google, github, ldap)."
        },
        "createdAt": {
          "type": "string",
          "description": "Timestamp indicating when the user account was created.",
          "format": "date-time"
        },
        "lastLogin": {
          "type": "string",
          "description": "Timestamp indicating the last time the user logged in.",
          "format": "date-time"
        },
        "roles": {
          "type": "array",
          "description": "Array of roles assigned to the user (e.g., user, admin).",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "id",
        "email",
        "passwordHash",
        "provider",
        "createdAt",
        "lastLogin",
        "roles"
      ]
    },
    "RefreshToken": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "RefreshToken",
      "type": "object",
      "description": "Represents a refresh token for user session management.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the RefreshToken entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N RefreshToken)"
        },
        "token": {
          "type": "string",
          "description": "The actual refresh token string (hashed)."
        },
        "expiryDate": {
          "type": "string",
          "description": "Timestamp indicating when the refresh token expires.",
          "format": "date-time"
        }
      },
      "required": [
        "id",
        "userId",
        "token",
        "expiryDate"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profile information.  Authorization is based on path-based ownership (`request.auth.uid == userId`).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/refreshTokens/{refreshTokenId}",
        "definition": {
          "entityName": "RefreshToken",
          "schema": {
            "$ref": "#/backend/entities/RefreshToken"
          },
          "description": "Stores refresh tokens associated with a user. Authorization is based on path-based ownership. (`request.auth.uid == userId`).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier for the user."
            },
            {
              "name": "refreshTokenId",
              "description": "The unique identifier for the refresh token."
            }
          ]
        }
      }
    ],
    "reasoning": "This Firestore data structure is designed to support user authentication and session management using JWTs and refresh tokens, aligning with the provided MVP requirements and design principles. The primary focus is on enabling secure, scalable, and debuggable security rules by prioritizing Authorization Independence and Structural Segregation.\n\n**Authorization Independence:** The structure avoids hierarchical authorization dependencies (`get()`) by not requiring access to parent documents to validate child documents.  All authorization checks can be performed directly on the requested document using `request.auth.uid`.  No denormalization is required for this MVP due to the simple data model.\n\n**Structural Segregation:** The structure separates user profiles and refresh tokens into distinct collections to enforce homogeneous security postures. The `/users/{userId}` collection stores user profiles, and the `/users/{userId}/refreshTokens/{refreshTokenId}` subcollection stores refresh tokens associated with each user. This segregation allows for granular security rules tailored to each entity's specific access requirements.\n\n**QAPs (Rules are not Filters):** The structure supports secure `list` operations by ensuring that list operations are scoped to the authenticated user's ID. For example, listing refresh tokens is done via `/users/{userId}/refreshTokens`, ensuring only the tokens belonging to the authenticated user are accessible. Global roles are not used in this MVP.\n\n**Invariants:** The structure supports the integrity of ownership by using path-based ownership for refresh tokens. Each refresh token is stored under `/users/{userId}/refreshTokens/{refreshTokenId}`, ensuring that only the user with the corresponding `userId` can access or manage their tokens."
  }
}